// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.
#include <list>

#include "gen-cpp/Example.h"
#include "gen-cpp/EventHandler.h"
#include <thrift/Thrift.h>
#include <thrift/transport/TSocket.h>
#include <thrift/server/TNonblockingServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/protocol/TCompactProtocol.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/concurrency/PosixThreadFactory.h>

using namespace std;
using namespace ::apache::thrift;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::concurrency;

template<class T1, class T2>
class ThriftService : public Runnable {
public:
  ThriftService(uint16_t port, uint16_t io_thread_count, T1* iface) :
    m_port(port),
    m_handler(iface),
    m_processor(new T2(m_handler)),
    m_transport_factory(new TBufferedTransportFactory()),
    m_protocol_factory(new TCompactProtocolFactory()),
    m_thread_manager(ThreadManager::newSimpleThreadManager(io_thread_count)),
    m_thread_factory(new PosixThreadFactory()) {

    m_thread_manager->threadFactory(m_thread_factory);
    m_thread_manager->start();
  }

  bool add_and_start_worker_thread(Runnable* runnable) {
    boost::shared_ptr<Runnable> wrapper(runnable);
    boost::shared_ptr<Thread> thread(m_thread_factory->newThread(wrapper));
    m_threads.push_back(thread);
    thread->start();
    return true;
  }

  virtual ~ThriftService() {}

  virtual void run() {
    TNonblockingServer server(m_processor, m_protocol_factory, m_port, m_thread_manager);
    server.serve();
  }

private:
  uint16_t m_port;
  boost::shared_ptr<T1> m_handler;
  boost::shared_ptr<TProcessor> m_processor;
  boost::shared_ptr<TTransportFactory> m_transport_factory;
  boost::shared_ptr<TProtocolFactory> m_protocol_factory;
  boost::shared_ptr<ThreadManager> m_thread_manager;
  boost::shared_ptr<PosixThreadFactory> m_thread_factory;
  std::list<boost::shared_ptr<Thread>> m_threads;
};

class ExampleHandler : virtual public ExampleIf {
public:
  ExampleHandler() {}

  void ping() {
    // Your implementation goes here
    //printf("ping\n");
  }

  bool registerHandler(const int16_t eventPort) {
    boost::shared_ptr<TSocket> socket(new TSocket("localhost", eventPort));
    boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
    boost::shared_ptr<TProtocol> protocol(new TCompactProtocol(transport));
    boost::shared_ptr<EventHandlerClient> client(new EventHandlerClient(protocol));

    printf("registerHandler(%d)\n", eventPort);
    transport->open();
    m_clients.push_back(client);
    printf("registerHandler complete\n");
    return true;
  }

  void wait() {
    // Your implementation goes here
    printf("Processing request: %d\n", m_requestNumber);
    //sleep(1);

    printf("Notifying clients: %d\n", m_requestNumber);
    for (auto iter = m_clients.begin(); iter != m_clients.end(); ++iter) {
      try {
        (*iter)->event(m_requestNumber);
      } catch(TException& ex) {
        printf("Exception: %s\n", ex.what());
        iter = m_clients.erase(iter);
      }
    }
    ++m_requestNumber;
  }

private:
  list<boost::shared_ptr<EventHandlerClient>> m_clients;
  int m_requestNumber = 0;
  int m_clientNumber = 0;

};

class MainThread : public Runnable {
public:
  MainThread() {}
  virtual ~MainThread() {}

  virtual void run() {
    while(true) {
      printf("Doing hardwork!\n");
      sleep(5);
    }
  }
};

int main(int argc, char **argv) {
  uint16_t port = 9090;
  uint16_t io_thread_count = 1;
  boost::shared_ptr<ThriftService<ExampleIf, ExampleProcessor>> service(
    new ThriftService<ExampleIf, ExampleProcessor>(port, io_thread_count, new ExampleHandler()));
  service->add_and_start_worker_thread(new MainThread());
  service->run();
  return 0;
}
